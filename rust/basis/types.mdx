---
title: 基本类型
slug: /rust/basis/types
sidebar_position: 2
---

Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：

- 数值类型: 有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数
- 字符串：字符串字面量和字符串切片 `&str`
- 布尔类型： `true`和`false`
- 字符类型: 表示单个 Unicode 字符，存储为 4 个字节
- 单元类型: 即 `()` ，其唯一的值也是 `()`

### 类型推导与标注
与 Python、JavaScript 等动态语言不同，Rust 是一门静态类型语言，也就是编译器必须在编译期知道我们所有变量的类型，但这不意味着你需要为每个变量指定类型，因为 Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型，同时编译器也不够聪明，在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注，关于这一点在 Rust 语言初印象中有过展示。

来看段代码：

`let guess = "42".parse().expect("Not a number!");`

先忽略 `.parse().expect..` 部分，这段代码的目的是将字符串 `"42"` 进行解析，而编译器在这里无法推导出我们想要的类型：整数？浮点数？字符串？因此编译器会报错：

```
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type
```

因此我们需要提供给编译器更多的信息，例如给 guess 变量一个显式的类型标注：`let guess: i32 = ...` 或者 `"42".parse::<i32>()`。

## 数值类型

### 整数类型
整数是没有小数部分的数字。之前使用过的 `i32` 类型，表示有符号的 32 位整数（ i 是英文单词 integer 的首字母，与之相反的是 `u`，代表无符号 `unsigned` 类型）。下表显示了 Rust 中的内置的整数类型：

|长度	|有符号类型	|无符号类型|
|-------|----------|---------|
|8 位	|i8	|u8|
|16 位	|i16	|u16|
|32 位	|i32	|u32|
|64 位	|i64	|u64|
|128 位	|i128	|u128|
|视架构而定	|isize	|usize|


类型定义的形式统一为：有无符号 `+` 类型大小(位数)。无符号数表示数字只能取正数和0，而有符号则表示数字可以取正数、负数还有0。就像在纸上写数字一样：当要强调符号时，数字前面可以带上正号或负号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以补码形式存储。

每个有符号类型规定的数字范围是 `-(2^n - 1) ~ 2^(n - 1) - 1`，其中 `n` 是该定义形式的位长度。因此 `i8` 可存储数字范围是 `-(2^7) ~ 2^7 - 1`，即 `-128 ~ 127`。无符号类型可以存储的数字范围是 `0 ~ 2^n - 1`，所以 `u8` 能够存储的数字为 `0 ~ 2^8 - 1`，即 `0 ~ 255`。

此外，`isize` 和 `usize` 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。

$$
e=mc^2
$$

整形字面量可以用下表的形式书写：

|数字字面量	|示例|
|----|----|
|十进制	|98_222|
|十六进制	|0xff|
|八进制	|0o77|
|二进制	|0b1111_0000|
|字节 (仅限于 u8)	|b'A'|






## 字符、布尔、单元类型


## 语句和表达式


## 函数