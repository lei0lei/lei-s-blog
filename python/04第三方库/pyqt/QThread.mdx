---
title: QThread
slug: /python/pyqt/qthread
sidebar_position: 2
---

pyqt gui应用有一个主线程在一直执行来运行事件循环和GUI。如果在这个线程中运行了
一个长期运行的任务，GUI就会在任务终止前一直被占用，在这期间用户无法和UI交互。
pyqt解决的方法是QThread.

扩展阅读:
- [pyqt-caculator](https://realpython.com/python-pyqt-gui-calculator/)
- [python threading](https://realpython.com/intro-to-python-threading/)

长期运行的任务会占用GUI应用的主线程，比如:


<p align="center">
<img src="https://realpython.com/cdn-cgi/image/width=302,format=auto/https://files.realpython.com/media/pyqt-freezing-gui.1a899db536e8.png" alt="win" width="400"/>
</p>

我们需要计算按钮的总点击次数，点击long running task之后会有一个占用很长时间的任务，
第一中方法使用单线程执行:
```py
import sys
from time import sleep

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QApplication,
    QLabel,
    QMainWindow,
    QPushButton,
    QVBoxLayout,
    QWidget,
)

class Window(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.clicksCount = 0
        self.setupUi()

    def setupUi(self):
        self.setWindowTitle("Freezing GUI")
        self.resize(300, 150)
        self.centralWidget = QWidget()
        self.setCentralWidget(self.centralWidget)
        # Create and connect widgets
        self.clicksLabel = QLabel("Counting: 0 clicks", self)
        self.clicksLabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.stepLabel = QLabel("Long-Running Step: 0")
        self.stepLabel.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        self.countBtn = QPushButton("Click me!", self)
        self.countBtn.clicked.connect(self.countClicks)
        self.longRunningBtn = QPushButton("Long-Running Task!", self)
        self.longRunningBtn.clicked.connect(self.runLongTask)
        # Set the layout
        layout = QVBoxLayout()
        layout.addWidget(self.clicksLabel)
        layout.addWidget(self.countBtn)
        layout.addStretch()
        layout.addWidget(self.stepLabel)
        layout.addWidget(self.longRunningBtn)
        self.centralWidget.setLayout(layout)

    def countClicks(self):
        self.clicksCount += 1
        self.clicksLabel.setText(f"Counting: {self.clicksCount} clicks")

    def reportProgress(self, n):
        self.stepLabel.setText(f"Long-Running Step: {n}")

    def runLongTask(self):
        """Long-running task in 5 steps."""
        for i in range(5):
            sleep(1)
            self.reportProgress(i + 1)

app = QApplication(sys.argv)
win = Window()
win.show()
sys.exit(app.exec())
```

`.setupUi()`创建了所有需要的图形组件，点击下方的long running按钮之后会有一个需要5s的任务，
但是如果在下方按钮运行期间点击上方按钮，ui会没有响应，上方按钮无法响应点击事件，上方的label
也不会改变。一直到下方任务运行完，上方状态才发生改变，也就是说程序被冻结了10s.这是由于主线程被
阻塞了，常见的解决方式是使用worker thread.


<p align="center">
<img src="https://realpython.com/cdn-cgi/image/width=325,format=auto/https://files.realpython.com/media/pyqt-freezing-gui-animation.03895ab5576e.gif" alt="win" width="400"/>
</p>

## 多线程

有时需要把程序分为几个小的子程序或者tasks,然后在几个线程中运行，这样也许可以使程序运行更快，或者防止
程序在执行长时间运行的时候没有响应。thread具有单独的执行流，在大多数操作系统中，线程是进程的组件，
进程可以同时执行多个线程。每个进程是程序或者应用实例。

我们可以有很多的线程数，确定合适的线程数，如果正在处理I/O受限的线程，线程数会被限制到可用的系统资源。
如果是CPU受限的，比cpu核数小的线程数会比较好。

构建可以使用不同线程运行多个不同任务的程序又叫多线程编程。多线程可以同时运行几个任务，但是并不总是这样，
至少有两个因素限制着同时运行多个线程:
1. CPU
2. 编程语言

如果是单核机器，就没法同时运行多个线程，有一个特例是使用操作系统提供的schedule功能来模拟多线程执行。
这样宏观来看是并行的但是同一时刻只有一个线程。

如果是多核机器或者计算机集群，可以同时运行多个线程，这样变成语言就变成重要的影响因素。

一些编程语言有内部的组件会禁止真正的多线程执行，这样线程表现为并行运行是受益于task调度系统。

多线程程序实际上很难写，很难维护以及debug.因为线程间共享资源，数据访问同步和协调线程执行很复杂
下面是一些可能产生的问题:

- race condition: 当由于事件的顺序不可预测时应用的行为也发生变化。通常两个或者多个线程在没有
合适的同步就访问共享资源就会导致这种情况。比如从不同线程读写内存，如果读写操作以不同顺序发生
就会导致这个问题。

- Deadlock：当线程一直等到被locked的资源释放时会发生。比如一个线程lock资源使用完后也没有unlock,
另一个线程就无法使用然后陷入一直等待。deadlock还会发生在A等待线程B unlock资源然后B等待线程A
unlock一个不同的资源，两个线程就会一直互相等待下去。

- Livelock: 两个或者多个线程重复性的互相响应互相的动作。Livelock的线程由于一直互相响应无法进行下
一步操作，但是这些线程并不处于blocked或者dead状态。

- starvation: 当一个进程永远无法访问需要的资源导致无法完成任务时。比如一个进程无法获得cpu时间，就无法
完成任务。

在构建多线程应用时，需要在并发写或者状态改变访问时要格外小心，换句话说需要阻止多个线程同时访问给定资源。

多线程程序至少有以下几种好处:
1. 利用多核处理器加速程序
2. 把程序变成子任务来简化应用
3. 让应用保持响应，防止长时间运行的任务阻塞程序

在cpython中，线程不会并行运行，因为GIL.

## qthread
pyqt使用qthread来创建多线程应用，pyqt有两种应用:

- 主线程
- 工作线程
主线程总是存在，应用和GUI在其中运行。工作线程取决于应用的处理需求，比如应用有一个
需要运行很长时间的任务。需要避免gui被阻塞。

### 主线程
主线程又叫做GUI线程，因为他处理所有的组件和其他的GUI元素。python在运行应用的时候就会启动
这个线程。在QApplication 对象上调用.exec()之后主线程就会启动事件循环。

默认情况下，发生在应用主线程的所有事件或者任务包括用户在GUI本身上的事件都是同步或者一个接一个运行的。
如果有一个长时间运行的任务，应用需要等待任务完成，期间GUI不响应。

需要注意必须在GUI线程中创建和更新所有组件。但是可以在工作线程中执行其他长期运行的任务然后把结果反馈
给GUI组件，GUI就像消费者一样从实际的工作线程中得到信息。

### 工作线程

pyqt应用中可以创建任意多的工作线程。使用QThread来创建工作线程，每个工作线程有自己的事件循环，支持pyqt的
signal and slot机制来和主线程通信。如果在特定线程中从继承自QObject的类中的对象，这个对象就属于这个线程。
其子类也属于这个线程。

Qthread本身不是一个线程，这是一个操作系统线程的封装器，真正的线程对象是在`QThread.start()`中创建的。

Qthread提供了高层的API来管理线程，包括信号，比如.started()和.finished(),在线程启动和结束的时候产生。还包含
方法和slots比如.start(),.wait(),.exit(),.quit(),.isFinished()以及.isRunning().

像其他的threading方案一样，使用QThread必须保护数据和资源，不然会有死锁，数据冲突等问题。


## qthread vs python thread

python标准库也提供了threading模块来实现多线程，到底该用哪个?一般在python应用中使用threading,
但是如果使用pyqt来构建GUI应用qthread会更好。一般pyqt的线程有以下好处:
- 线程相关的类跟pyqt结构集成紧密
- worker thread有其自己的事件循环，可以处理事件。
- 线程内部通信可以使用signal跟slot

## 使用qthread 防止ui卡住

在GUI应用中使用线程通常就是把长期运行的任务交给工作线程，这样UI还能响应用户的交互，
pyqt中使用QThread来管理工作线程。

QThread创建工作线程主要有两种方式:
- 直接实例化QThread创建QObject worker.然后用这个线程作为参数在worker上调用`.moveToThread()`,
worker必须包含执行特定任务所需要的功能。
- 创建QThread的子类然后重新实现`.run()`。`.run()`的实现必须包含需要的功能。

实例化QThread提供了并行的事件循环，事件循环让线程拥有的对象在slots上接受信号，这些slots在线程内执行。

换句话说，QThread的子类可以在事件循环之外运行并行代码，这种方法可以通过明确调用exec()创建事件循环。

要使用第一种方式需要以下步骤:
1. 创建QObject的子类来准备worker对象并且把长期运行的任务放进去
2. 创建worker类的新实例
3. 创建QThread实例
4. 通过调用`.moveToThread(thread)`把worker对象放到新创建的线程
5. 把需要的信号和slots创建关联来创建线程通信
6. 在QThread对象上调用`.start()`

```py
from PyQt5.QtCore import QObject, QThread, pyqtSignal
# Snip...

# Step 1: Create a worker class
class Worker(QObject):
    finished = pyqtSignal()
    progress = pyqtSignal(int)

    def run(self):
        """Long-running task."""
        for i in range(5):
            sleep(1)
            self.progress.emit(i + 1)
        self.finished.emit()

class Window(QMainWindow):
    # Snip...
    def runLongTask(self):
        # Step 2: Create a QThread object
        self.thread = QThread()
        # Step 3: Create a worker object
        self.worker = Worker()
        # Step 4: Move worker to the thread
        self.worker.moveToThread(self.thread)
        # Step 5: Connect signals and slots
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)
        self.worker.progress.connect(self.reportProgress)
        # Step 6: Start the thread
        self.thread.start()

        # Final resets
        self.longRunningBtn.setEnabled(False)
        self.thread.finished.connect(
            lambda: self.longRunningBtn.setEnabled(True)
        )
        self.thread.finished.connect(
            lambda: self.stepLabel.setText("Long-Running Step: 0")
        )
```

## 线程复用:QRuunable和QThreadPool
如果GUI引用很依赖于多线程，在创建和销毁线程就会有很大的负载，需要考虑在系统上可以启动多少线程。
每个应用都会有一个全局线程池，通过调用`QThreadPool.globalInstance()`得到其引用。

:::note

使用默认的线程池很常见，也可以实例化 `QThreadPool`来创建自己的线程池。

:::

全局线程池会根据当前cpu的核数来维护和管理建议数量的线程。还会管理应用线程队列和任务执行。
线程池中的线程是可复用的，防止创建和销毁线程需要的负载。

要创建任务并在线程池中运行，使用QRunnable.这个类表示需要运行的任务或者一块代码，这个过程包含3个步骤:
1. 创建QRunnable的子类，重新根据任务实现`.run()`
2. 实例化QRunnable的子类来创建可运行的任务
3. 调用`QThreadPool.start()`来运行任务。

.run()必须包含任务运行需要的代码。.start()调用把任务交给线程池中的可用线程，如果没有可用线程，.start()
会把任务放到线程池的运行队列，在线程可用的时候.run()会执行。

```py
import logging
import random
import sys
import time

from PyQt5.QtCore import QRunnable, Qt, QThreadPool
from PyQt5.QtWidgets import (
    QApplication,
    QLabel,
    QMainWindow,
    QPushButton,
    QVBoxLayout,
    QWidget,
)

logging.basicConfig(format="%(message)s", level=logging.INFO)

# 1. Subclass QRunnable
class Runnable(QRunnable):
    def __init__(self, n):
        super().__init__()
        self.n = n

    def run(self):
        # Your long-running task goes here ...
        for i in range(5):
            logging.info(f"Working in thread {self.n}, step {i + 1}/5")
            time.sleep(random.randint(700, 2500) / 1000)

class Window(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setupUi()

    def setupUi(self):
        self.setWindowTitle("QThreadPool + QRunnable")
        self.resize(250, 150)
        self.centralWidget = QWidget()
        self.setCentralWidget(self.centralWidget)
        # Create and connect widgets
        self.label = QLabel("Hello, World!")
        self.label.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
        countBtn = QPushButton("Click me!")
        countBtn.clicked.connect(self.runTasks)
        # Set the layout
        layout = QVBoxLayout()
        layout.addWidget(self.label)
        layout.addWidget(countBtn)
        self.centralWidget.setLayout(layout)

    def runTasks(self):
        threadCount = QThreadPool.globalInstance().maxThreadCount()
        self.label.setText(f"Running {threadCount} Threads")
        pool = QThreadPool.globalInstance()
        for i in range(threadCount):
            # 2. Instantiate the subclass of QRunnable
            runnable = Runnable(i)
            # 3. Call start()
            pool.start(runnable)

app = QApplication(sys.argv)
window = Window()
window.show()
sys.exit(app.exec())
```

注意:print不是线程安全的最好使用logging.

在python外面无法中止QRunnable对象，可以创建一个全局的布尔值，然后在QRunnable的子类中进行检查来终止。

## Worker qthread通信

在使用pyqt进行多线程编程的时候，可能需要在主线程和工作线程间建立通信，这样可以得到从工作线程的反馈
来更新UI或者把数据发送给线程或者中断执行等。

pyqt的信号和slot机制给线程间通信提供了健壮并且安全的方式。另一方面可能需要在工作线程之间建立通信，
比如共享的buffer数据或者其他资源，这种情况下需要确保避免同时访问。
### 使用信号和slots
线程安全的对象是指可以被多个线程同时访问的对象，并且总是可靠的。pyqt的信号和slots是线程安全的，可以创建
线程间通信并在线程间共享通信。

线程产生的信号可以连接到该线程或者不同的线程，这表示可以在一个线程内执行代码来响应同一线程产生的信号或者
另一个线程产生的信号。

响应式GUI例子中，使用信号和slots机制来在线程间建立通信，比如把worker的progress信号连接到应用的`.reportProgress()`slot
progress有一个表示长期运行的任务的整数值，`.reportProgress()`收到这个值作为参数，这样可以更新Long-Running Step label.

### 线程间共享通信
多线程一般需要多个线程访问同一份数据和资源，如果多个线程并行访问相同的数据和资源，并且至少其中之一写入或者
改变了共享资源，可能会面临程序崩溃，内存或者数据冲突，死锁等乱七八糟的问题。

有至少两种方法来保护数据或者资源:
1. 用下面的方式避免共享状态
    - immutable objects
    - thread-local storage
    - reentrant code
2. 使用下面的方法同步访问共享数据
    - atomic operation
    - mutual exclusion

如果需要共享资源，需要使用第二种方法。原子操作在单个执行步出现，因此无法被其他线程打断，确保
只有一个线程在给定事件更改资源。

:::note
[CPython如何管理原子操作的?](https://docs.python.org/3/faq/library.html#what-kinds-of-global-value-mutation-are-thread-safe)
:::

mutual exclusion是多线程中常用的模式。通过locks来保护数据和资源的访问，这是一种同步机制，给定时间只允许一个线程访问资源。
比如如果线程A需要改更新全局变量，就会在该变量上得到一个锁，防止线程B同时访问变量。线程A完成
变量更新之后，释放锁,线程B才可以访问变量。

使用锁会有额外的花费导致性能下降。线程同步强制大多数线程等待直到某个资源可用，无法从并行执行上得到好处。

pyqt有一些方便的类来在并行访问中保护资源和数据:

- QMutex是一个lock class来管理mutual exclusion,
- QReadWriteLock类似于QMutex,但是会区分读写访问，多个线程可以同时通过只读的方式访问共享资源。如果线程需要
写资源，所有线程都会阻塞直到写完成。
- QSemaphore是复数版本的QMutex,可以保护一组唯一的资源，如果信号量保护了n个资源，尝试锁定n+1个资源，就会
阻塞信号量，防止访问资源。

### QMutex保护共享数据

QMutex常用来防止多线程的pyqt应用同时访问共享的数据和资源。接下来是一个QMutex的例子，管理一个银行账户，两个人可以
在任何事件取钱，这种情况下需要在并行访问的时候保护账户，不然可以取比账户更多的钱。

受限import一些内容:
```py
import logging
import random
import sys
from time import sleep

from PyQt5.QtCore import QMutex, QObject, QThread, pyqtSignal
from PyQt5.QtWidgets import (
    QApplication,
    QLabel,
    QMainWindow,
    QPushButton,
    QVBoxLayout,
    QWidget,
)

logging.basicConfig(format="%(message)s", level=logging.INFO)

balance = 100.00
mutex = QMutex()
```
balance是一个放余额的全局变量，mutex是QMutex对象，使用其来防止多个线程同时访问balance.

接下来创建QObject的子类来放取钱逻辑的代码:
```py
class AccountManager(QObject):
    finished = pyqtSignal()
    updatedBalance = pyqtSignal()

    def withdraw(self, person, amount):
        logging.info("%s wants to withdraw $%.2f...", person, amount)
        global balance
        mutex.lock()
        if balance - amount >= 0:
            sleep(1)
            balance -= amount
            logging.info("-$%.2f accepted", amount)
        else:
            logging.info("-$%.2f rejected", amount)
        logging.info("===Balance===: $%.2f", balance)
        self.updatedBalance.emit()
        mutex.unlock()
        self.finished.emit()
```

这里首先定义了两个信号:
1. finished表示何时类处理任务
2. updatedBalance表示何时balance进行更新

然后定义`.withdraw()`,在这个方法中:
- 显示取钱的人
- 使用golbal语句从`.withdraw()`中使用balance变量。
- 在mutex上调用.lock()来获得lock，保护balance
- 检查balance是否允许取钱
- 调用sleep模拟操作所需的时常
- 减小取出的钱
- 显示是否允许交易的信息
- 铲射高updatedBalance信号表示balance已经被更新
- 释放锁让其他线程访问balance
- 产生finished信号表示操作完成

下面是UI:
```py
class Window(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setupUi()

    def setupUi(self):
        self.setWindowTitle("Account Manager")
        self.resize(200, 150)
        self.centralWidget = QWidget()
        self.setCentralWidget(self.centralWidget)
        button = QPushButton("Withdraw Money!")
        button.clicked.connect(self.startThreads)
        self.balanceLabel = QLabel(f"Current Balance: ${balance:,.2f}")
        layout = QVBoxLayout()
        layout.addWidget(self.balanceLabel)
        layout.addWidget(button)
        self.centralWidget.setLayout(layout)
```

```py
class Window(QMainWindow):
    # Snip...
    def createThread(self, person, amount):
        thread = QThread()
        worker = AccountManager()
        worker.moveToThread(thread)
        thread.started.connect(lambda: worker.withdraw(person, amount))
        worker.updatedBalance.connect(self.updateBalance)
        worker.finished.connect(thread.quit)
        worker.finished.connect(worker.deleteLater)
        thread.finished.connect(thread.deleteLater)
        return thread
```

这里的代码为每个人创建了一个线程，将线程的started信号和worker的.withdraw()进行关联，
线程启动时会自动运行方法。这里还把updatedBalance信号和.updateBalance()关联，更新当前的
balance.

```py
class Window(QMainWindow):
    # Snip...
    def updateBalance(self):
        self.balanceLabel.setText(f"Current Balance: ${balance:,.2f}")
```

接下来为两个人创建线程:
```py
class Window(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setupUi()
        self.threads = []

    # Snip...
    def startThreads(self):
        self.threads.clear()
        people = {
            "Alice": random.randint(100, 10000) / 100,
            "Bob": random.randint(100, 10000) / 100,
        }
        self.threads = [
            self.createThread(person, amount)
            for person, amount in people.items()
        ]
        for thread in self.threads:
            thread.start()
```
首先给Windown的初始化器添加.thread作为实例属性，这个变量存放线程列表防止.startThreads()
返回后脱离作用域，然后定义.startThread()创建两个人，每人一个线程。


在startThread()中进行了下面操作:
- 清楚已经摧毁的线程
- 创建字典存放两个人
- 每人一个线程
- for循环中启动线程


<p align="center">
<img src="https://realpython.com/cdn-cgi/image/width=653,format=auto/https://files.realpython.com/media/account-manager-example.ed39ea2ca678.gif" alt="" width="400"/>
</p>



## 总结
一些经验之谈:
- 避免在主线程中有长期运行的任务
- 使用 QObject.moveToThread()和QThread对象创建工作线程
- 如果需要管理工作线程池，使用QThreadPool和QRunnable
- 使用信号和slots来创建安全的线程间通信
- 使用QMutex,QReadWriteLock或者QSemaphore来防止线程同时访问共享数据和资源
- 在终止线程之前一定要解锁或者释放QMutex,QReadWriteLock或者QSemaphore
- 使用多个return语句在函数的所有可能的执行路径上释放锁
- 不要在工作线程内创建访问或者更新GUI元素或者组件
- 不要把有父子关系的QObject移动到不同的线程内